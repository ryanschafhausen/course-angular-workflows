
Basic testing setup with the CLI

- [Instructor] We will first be taking a look at different testing workflows and several things that you can do to improve both developer experience and productivity. The CLI does so much for you in setting up your unit and then to a testing infrastructure. But there are several things that you can do to customize your workflow. Let's go ahead and open up the exercise files for this video and run npm install. I've already done it here. I have provided a sample application that was generated with the Angular CLI called the Grid. Let's run npm start to see what it looks like and then we'll take a look at the internals and how it all works. Open up the terminal here and run npm start. The app opens in our default browser and it has a sample application showing tabular data. We can search by status and by name and we can click on a row and view the details. We also have another view showing a chart. Let's take a look now at the internals and head over to the package.json file. We have a few npm scripts setup here. We are using json-server which provides a quick REST API for prototyping. It uses a sample db.json file which includes a list of hackers and we are specifying that the API routes will be redirected to the root. In your browser, you can open up localhost port 3000 and we see a confirmation page. Heading to /api/hackers will return our list of hackers. Let's head back to the package.json file. The start:client script use ng serve along with a proxy configuration file. Because ng serve uses a local web pack dev server at port 4200 and we have a proxy API running in port 3000, we need to proxy requests. We will proxy requests to /api to the json-server that was setup. This application also includes a sample test suite which includes tests for most components, services, and directives. You can head to a particular component and view the sample unit test. Looking at our npm scripts, this is simply run by running npm test. Let's go ahead and open up our terminal and run npm test. I'm going to kill the server using Control + C, clear my terminal, and then run npm test. The CLI is compiling our tests since we can write our tests in TypeScript and runs our suite against an instance of Chrome and then exits. We can see that all 27 tests are passing. The CLI does a fantastic job in setting this up for us as you don't have to write this configuration yourself.

Generating code coverage reports

- One of the important things to do while testing your code is to generate code coverage reports. To do so, you can use a code coverage flag: ng test --code-coverage. What this would do is generate code coverage reports using Istanbul. Let's wait for a test to run. You can see in the file explorer, we now have a new coverage folder. Let's go ahead and open the index.html file in our browser. What you see here is a coverage report indicating the files and lines that have been tested through your spec files. Green means that we have tested the underlying code, while red means that it is untested code. It is important to know that this will only generate code coverage reports on lines of code that have run through a unit test. If you don't run a specific file through your unit test, it won't be included in the coverage report. Another quick thing to configure is to run our tests on Chrome Headless. Currently, running our test spins up an instance of Chrome. As of version 59 of Chrome, you can run Chrome Headless. It has the benefit of giving you a real browser context without the memory overhead of running a full version of Chrome. Also, your Javascript test will be executed in the same environment as users of your site. To do so, we can simply change the configuration in our karma file. It's under src, karma.conf.js, I can scroll down to line 28 and change Chrome to ChromeHeadless. Let's run our test suite again. Let me clear my terminal and run ng test --code-coverage. Our suite runs again, successfully, but this time, it is using Chrome Headless.

Configuring terminal reporting

- [Instructor] Currently, when we run our test suite, all we are told is that our test would pass with 27 tests. It's a little difficult to know which test exactly ran. In a continuous integration environment, it will be very helpful to have more detailed information. Let's update our terminal reporting. Let's start by installing the karma-spec-reporter and use the -D tag to save in our dev dependencies. It looks like I misspelled that. It's karma-spec-reporter. We will be updating the karma.config.js file here. First thing we need to do is add it to our plugins, require karma-spec-reporter. Let's head down to line 21 here in the reports property, and we will ad a new token, and that is text-summary. Finally, in line 24, replace progress with spec here. Let's go ahead and run our test suite again with --code-coverage. Now, when we run our test suite, you will get a much more detailed output. We see the status of each test, and at the end, we get a text summary of our overall code coverage.

Setting NPM scripts for testing

- [Instructor] Setting up npm strips provides a great way to abstract long commands into a simple one. We have been using this command quite often, ng test --code-coverage. But we don't want to type this in every time we want to run our test suite. We can simply replace the current npm test script with this. Head over to your package.json, the scripts area. And we see the test npm script simply runs ng test. Let's go ahead and update this. Add the --code-coverage flag. I will also use the --progress flag, and set that to false to mute some of the verbose output. In our terminal, we can now run npm test. Sometimes it is very useful to run your tests in watch mode and have your test re-run whenever you change your code. Let's go ahead and add another script here. I will call it test:watch, ng test, use the --code-coverage flag, also the --progress flag set to false, and I will add a new one, which is the --watch. Let's run this script at the terminal, npm run test:watch. When we run this at our terminal, our suite runs, and then sits there listening for any changed files, ready to run again.

Enforcing code coverage

- [Instructor] We previously saw how we can generate code coverage reports. When trying to establish a test-driven culture within your teams it may be a good idea to enforce code coverage thresholds. There are mixed opinions on whether or not you should do this. Sure, a code with some 99% coverage may not necessarily mean that your code is bug-free. But tested code is one major step in the way of producing clean code. Enforcing coverage thresholds will promote testability among your team. 'Specially if your team is new to testing, and you can ensure that untested code is not making it's way to your code base. Head over to the karma.conf.js file, and then we'll configure the thresholds. Let's add a new property here. Thresholds. And let's configure first the global thresholds. For statements, branches, lines, and functions. 80 is an arbitrary percentage that I chose. But I think it is a good one to shoot for. You may also configure individual file thresholds using the exact same properties if you wish to enforce this per file. We can copy this, and add another property, and just change this to each. However, I find that having just a global coverage works great. So I'm gonna go ahead and delete this. Now with this set, even though all of my tests are passing, but the global coverage falls below any of these thresholds, the test suite will fail. The current code coverage on this application is higher than this. So let's modify for demonstration purposes. I will change the functions percentage to 90 and run my test suite again. Npm test. The test suite runs. And although, all of my tests are passing, the test suite failed because the coverage for functions did not meet its global threshold. And we can see that error here. We can set that back to 80 and run our test again. And we can see that all of our specs are passing and the coverage thresholds are met.

Configuring commit hooks with Husky

- [Instructor] Let's take a look now at how we can provide gateway checks when committing our code. Commit hooks are a great way to run certain checks to ensure clean code and provide a great way to prevent bad commit whether that is code that fails to pass linting, desired formatting, or even a failing test suite. Husky can be used to easily configure git hooks. It's an npm package so let's install it. In our terminal, we run npm install -D husky. Once it's installed, we can go ahead and configure a precommit hook in our package.json by simply adding a precommit npm script. Let's add precommit here and for our precommit script, we just want to run our linter, npm run lint, which will then in turn run ng lint. Let's test this by making a change. Head over to the hacker-detail.component and let's remove the implements OnInit. Now because I have the TSLint plugin for VS Code, my editor is telling me of this error. But let's say I try to commit this file, git add git commit adding precommit hook. You can see that Husky is running the precommit hook and linting will fail. This has prevented me from committing these changes. Let's fix the error. Let me add the file again and try to commit adding precommit hook. Husky runs again. All files will pass linting and our code was committed. You can also add a prepush hook for say running your tests. But in a later video, we'll be running our tests in a continuous integration environment.

Installing and Configuring Prettier

- [Instructor] We will now be taking a look at how we can integrate Prettier in an Angular project. Prettier is an opinionated code formatter that has been making developers happy by having their code magically formatted in a clean, consistent style. Ensuring clean, formatted code should definitely be a part of your work flow. And you may not know it, but Prettier has TypeScript support. That means you can easily integrate it into your Angular project, however, there's TSLint, so how the two work together? It's simple, we can leave the code quality rules for TSLint to handle, and we can have Prettier take care of formatting rules. Let's go ahead and install Prettier. Set out to our project here, and npm install -D prettier. Next we need to configure Prettier. Let's look at some of the defaults that Prettier has. The print width is 80. It uses two spaces and not tabs. Semicolons. Single quotes. No trailing commas, and bracket spacing. If you don't provide a configuration file, it will use these defaults, but even if your configuration matches the default, it's still a good idea to explicitly provide a configuration file, so that everyone on your team including you, knows exactly what options Prettier is using. Set back to our project here, and we're gonna create a Prettier configuration file. Let's create a file .prettierrc. And let's start specifying our configuration. Our printWidth, let's set that to 100, singleQuote, want that to be true, useTabs is false, but we use two spaces, tabWidth will be two, semicolons will be true, and we will use bracketSpacing. This is useful for things like formatting imports. Next, let's configure Prettier to ignore certain files. We don't necessarily want Prettier to format all supported files, and that is configurable as well. Let's create a Prettier ignore file, .prettierignore. There are some files that I recommend you ignore. Your package.json, your package-lock.json, your tslint.json, and some YAML files. The next thing I recommend doing is configuring your editor and install the Prettier extension. It's available for every major text editor and IDE. I'm using Visual Studio code. So let's search for the Prettier extension here. And we see it right here, let's install it, and it's gonna prompt me to reload Visual Studio code. Now that it is installed, we should also configure our editor to format on save. Let's open up our settings, and we can search here for format on save, and we wanna change that to true. Let's go ahead and save that file. We can close this out. Now let's try it out. Let's set to a file that may not necessarily be formatted. Head over to the hacker-search component. You can see that there's an awkward line break with the EventEmitter and also with the pipe operator. Let's save our code, hitting Command or CTRL + S, and just like that our code is automatically formatted. Sometimes you may not get exactly the desired output, but you can trust Prettier in that it will format in the most readable format possible. And also a plus, you no longer have to waste time on formatting issues with your teammates, as Prettier will handle it for you.

Integration with TSLint

- [Instructor] We previously configured a precommit hook to run TSLint on our staged files, and you can see this in line 12. TSLint is great for checking code and style errors when working with TypeScript and Angular, but Prettier does a much better job at code formatting. While you can configure TSLint to check for code formatting such as single quotes and semicolons, we want to leave that for Prettier. So how do the two work together? It's simple, we can leave the code quality rules for TSLint to handle, and we can have Prettier take care of formatting rules. The next step in integrating Prettier into our Angular app, is to remove the code formatting rules from TSLint and let Prettier handle that. Let's head over to the tslint.json file, and delete the rules that deal with code formatting. Let's leave the comment-format rules, which enforces formatting for single line comments, the curly rule, which adds curly braces for things like if blocks, the end of line rule, the import-spacing rule, which ensures proper spacing between import statements and keywords, the indentation rule, the max-line-length rule, which we set in Prettier to 100 characters, the no-trailing-whitespace rule, the quotemark rule for strings, the semicolon rule, and lastly, these two whitespace rules. We can go ahead and run npm run lint to make sure everything is still working correctly.

Configuring precommit hook

- [Instructor] In addition to the precommit hook that runs TSLint, we can use this hook to format staged files if for some reason they weren't automatically formatted during editing when we use this along with a package called pretty-quick to run Prettier on our staged files. Install these packages along with npm-run-all which will make it easier for us to run npm scripts. Let's go ahead and install them, npm install pretty-quick and then npm-run-all and save that to our DAF dependencies. In our precommit hook, we first want to run Prettier, then run TSLint on the formatted files. To make our scripts cleaner, I am using npm-run-all package which gives you two commands, run-s to run npm scripts in sequence and run-p to run them in parallel. Here I will use run-s to run these npm scripts in sequence and I will run format:fix npm scripts and then run the lint npm script. Let's go ahead and add the format:fix npm script now. This will use the pretty-quick tool and will pass in the flag --staged which instructs it to run Prettier on the changed files, then re-add them using git. Now when you commit your staged files, it will first format your files and then run those through TSLint. Let's test this out by heading over to the hacker-search-component and I'm going to update the debounceTime to 600 milliseconds. I'm also gonna mess with the formatting a bit just to test this out and you can see my format saved is running there so let's turn that off for a bit. Let me set this to false. Let's go ahead and try to commit this file now, git add, git commit -m updating debounce time. We see that Husky runs our precommit hook, then pretty-quick runs Prettier against our staged files and it tells us here that it formatted and then TSLint runs. Once everything checks, it successfully commits. Automating this workflow will be very beneficial to your projects.

Continuous integration intro

- [Instructor] Let's take a look now at continuous integration. Continuous integration is a development practice or strategy where developers continually commit small increments of code several times a day into a shared code repository. This code repository is automatically built and tested before it is merged. And we typically use a service like CircleCI to aid in the process. What process do we follow? Say we are working on a new feature. We first create a new feature branch. We commit our work and push up your branch. At this point, your CI server will run automated build and tests. If your build and tests pass, then your status is green, and you can merge. If not, then your status is red, and you have to fix the issues. There are many benefits to using continuous integration, or CI for short. It improves team productivity and efficiency. You find problems earlier, and you're able to ship quicker.

Setting up CircleCI

- [Instructor] We will now set up CircleCI which will allow us to run continuous integration for our library. But first, let's push our project up to GitHub. Let's create a new project here. We will name it ng-component. And create repository. We want to push an existing repository from the command line. Let us copy this, and head over to our terminal, and we add the remote, and now we can push this up to GitHub, git push origin -u master. And let's verify that it's up in GitHub. We can refresh here, and now out project is up in GitHub. Let's now define the CircleCI configuration, first, create a .CircleCI folder, and import the config.yml file provided in the exercise files. Grab the config.yml, and import it into that folder. Let's review this file, it is a CircleCI configuration. First, we specify that it is version two of CircleCI. Next, we define some common references to be used throughout our configuration. A setup, where we define a docker image that contains the browsers we need, and two references for dependency management, which will allow us to save, cache, and restore from cache. This can really speed up builds, as it doesn't have to pull down dependencies, unless something changed. Next, we start defining our jobs. We have a checkout-and-install job, which simply checks out the project and installs dependencies. We have a test job, which runs our MPM script, test:lib. And our build job, where we check out the project, restore dependencies, and run the MPM script build:lib. CircleCI allows you to set up workflows, which is how we connect the jobs together. We have one workflow, test-and-build, where we checkout-and-install, run the test job which requires checkout-and-install, and then we run the build job, which requires the test job to pass. Let's commit this file to our repository and push it up to GitHub. Git commit adding CircleCI configuration. And we git push. Head over now to circleci.com, and log in with your GitHub account. While CircleCI does have a priced tier, it is free for public projects. Head to the add projects tab, find your projects, and click set up project, choose linux as your operating system, node, and we start building our project.

Continuous integration workflow

- [Instructor] Now that we have a Circle configuration file, we can set up our GitHub project to work with CircleCI. Head to the settings tab, then the branches tab and we want to protect the master branch. Click protect this branch and we want to require certain status checks to pass before merging. You can see that the build jobs from the CircleCI configuration show up here. We want to verify checkout and install and the build and test jobs. Let's go ahead and save these changes. Let's use our continuous integration workflow. Let's head back to our project here. One quick thing that I have done here is I've updated the dependency cache name. Sometimes CircleCI will fail because of the cache so changing the name is a good first step in troubleshooting this. We first create a feature branch, git checkout -b feature/update-default-color. Head over to your component. It's under projects, your library, and the component file. Instead of the default green, we want to return a default yellow. Let's add a test for this and we will use snapshot testing. It should set pulse color to yellow when input is undefined or null, let's set this to null and let's run our test using Jest, npm run test:lib. Our snapshot file should have been updated. Let's verify that. We see that it is here and when the input is undefined or null, the class is set to yellow. Great, let's commit this file now, git add, git commit update default color to yellow and let's push this branch up to GitHub now, git push origin -u feature/update-default-color. Heading to our GitHub account, we can now open up a pull request. Let's create pull request and we automatically see the gateway checks that are running. I will not be able to merge this pull request unless all of these jobs pass and you can see the status running in CircleCI. Here's the build running and we could check out the workflows here or we checkout and install test and it is currently in the build step. It looks like everything checked out correctly. We may need to refresh here and I have my three checks passing so I'm able to merge my pull request.
